{"version":3,"sources":["components/Graph.tsx","components/Forecast.tsx","components/ForecastMap.tsx","lib/snogylop.js","App.tsx","reportWebVitals.ts","index.tsx"],"names":["ForecastGraph","forecast","hours","start","timeseries","time","end","length","d","Date","setHours","getHours","push","toISOString","timeLabelsInHours","properties","temp_values","precip_values","forEach","step","index","data","details","precip_6hours","i","temperature","x","y","type","name","mode","yaxis","visible","connectgaps","marker","color","size","precipitation","opacity","layout","width","height","title","geometry","coordinates","xaxis","showgrid","zeroline","showline","yaxis2","side","overlaying","config","displayModeBar","Forecast","position","useState","setForecast","useEffect","a","lat","Math","round","lng","url","fetch","response","json","fetchForecastData","then","body","DefaultIcon","L","icon","iconUrl","shadowUrl","iconShadow","ForecastMarker","setPosition","useMapEvents","click","e","latlng","Marker","Popup","ForecastMap","boundary","setBoundary","fetchEthiopiaBoundary","ok","new_boundary","isFlat","LineUtil","_flat","worldLatlngs","latLng","Polygon","prototype","toGeoJSON","extend","_setLatLngs","latlngs","this","_originalLatLngs","options","worldLatLngs","newLatlngs","l","Polyline","call","getBounds","LatLngBounds","getLatLngs","precision","holes","multi","coords","GeoJSON","latLngsToCoords","getFeature","defineSnogylop","InvertPolygonExtension","console","log","MapContainer","center","zoom","scrollWheelZoom","TileLayer","attribution","pathOptions","fill","fillColor","fillOpacity","App","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.af482870.chunk.js","sourcesContent":["import Plot from 'react-plotly.js';\nimport {WeatherGeoJSON, Forecast} from './METWeatherJSON';\n\ntype ForecastGraphProps = {\n    forecast: WeatherGeoJSON;\n}\n\nexport default function ForecastGraph({forecast}: ForecastGraphProps) {\n    let hours: string[] = timeLabelsInHours(forecast.properties)\n    let temp_values:  (number|null)[] = []\n    let precip_values: number[] = []\n \n    forecast.properties.timeseries.forEach((step, index) => {        \n        if (step.data[\"next_1_hours\"]){\n            precip_values.push(step.data[\"next_1_hours\"].details[\"precipitation_amount\"])\n            temp_values.push(step.data[\"instant\"].details[\"air_temperature\"])\n\n        }else if (step.data[\"next_6_hours\"]){\n            const precip_6hours = step.data[\"next_6_hours\"].details[\"precipitation_amount\"]\n            for (let i = 0; i < 6; i++){\n                precip_values.push(precip_6hours/6)\n            }\n            for (let i = 0; i < 5; i++){\n                temp_values.push(null)\n            }\n\n            temp_values.push(step.data[\"instant\"].details[\"air_temperature\"])\n        }\n    })\n\n    const temperature: Plotly.Data =\n        {\n            x: hours,\n            y: temp_values,\n            type: \"scatter\",\n            name: \"Temperature\",\n            mode: \"lines\",\n            yaxis: \"y\",\n            visible: true,\n            connectgaps: true,\n            marker: {\n                color: 'rgb(220,20,60)',\n                size: 12\n            },\n        }\n\n    const precipitation: Plotly.Data =\n        {\n            x: hours,\n            y: precip_values,\n            type: \"bar\",\n            name: \"Precipitation\",\n            yaxis: \"y2\",\n            opacity: 0.3,\n            visible: true,\n            marker: {\n                color: 'rgb(30,144,255)',\n            },\n        }\n\n    return (\n        <Plot\n            data = {[temperature, precipitation]}\n\n            layout = {{\n                width: 740,\n                height: 400,\n                title: \"Forecast for lat: \" + forecast.geometry.coordinates[1] + \", long: \" + forecast.geometry.coordinates[0],\n                xaxis: {\n                    title: 'Time',\n                    showgrid: true,\n                    zeroline: false\n                },\n                yaxis: {\n                    title: 'Celsius',\n                    zeroline: false,\n                    showgrid: false,\n                    showline: true\n                },\n                yaxis2: {\n                    title: \"Precipitation (mm/h)\",\n                    zeroline: false,\n                    showgrid: false,\n                    side: \"right\",\n                    overlaying: \"y\"\n\n                }\n            }}\n            \n            config={{displayModeBar: false}}\n        />\n\n    )\n}\n\nfunction timeLabelsInHours(forecast: Forecast) {\n    let start = forecast.timeseries[0].time\n    let end = forecast.timeseries[forecast.timeseries.length - 1].time\n\n    let hours: string[] = []\n    for (let d = new Date(start); d <=  new Date(end); d.setHours(d.getHours() + 1) ){\n        hours.push(d.toISOString())\n    }\n\n    return hours\n}","import {useEffect, useState} from 'react';\nimport ForecastGraph from './Graph';\nimport {Weather, WeatherGeoJSON} from \"./METWeatherJSON\";\n\nconst base_url = 'https://api.met.no/weatherapi/locationforecast/2.0/complete.json?'\n\ntype ForecastProps = {\n    position: L.LatLng\n}\n\nexport default function Forecast({position}: ForecastProps) {\n    const [forecast, setForecast] = useState<Weather>(null)\n\n    useEffect(() => {\n        const fetchForecastData = async () => {\n            let lat = Math.round(position.lat * 1000) / 1000\n            let lng = Math.round(position.lng * 1000) / 1000\n            const url = `${ base_url }lat=${lat}&lon=${ lng }`\n\n            const response = await fetch(url)\n            return await response.json() as WeatherGeoJSON\n        }\n        fetchForecastData().then((body: WeatherGeoJSON) => {\n            setForecast(body)\n        })\n    }, [position]);\n\n    return forecast == null ?\n        (\n            <p>Waiting...</p>\n        ):\n        (\n            <ForecastGraph forecast={forecast} />\n        )\n}","import L, { LatLngExpression, PathOptions } from \"leaflet\";\nimport { GeoJsonObject } from \"geojson\";\nimport \"leaflet/dist/leaflet.css\";\nimport { MapContainer, Marker, TileLayer, Popup, useMapEvents, GeoJSON } from \"react-leaflet\";\nimport { useState, useEffect } from \"react\";\nimport Forecast from \"./Forecast\";\nimport InvertPolygonExtension from \"../lib/snogylop.js\";\n\n// Hack to get marker icon to work\nimport icon from 'leaflet/dist/images/marker-icon.png';\nimport iconShadow from 'leaflet/dist/images/marker-shadow.png';\n\nlet DefaultIcon = L.icon({\n    iconUrl: icon,\n    shadowUrl: iconShadow\n});\nL.Marker.prototype.options.icon = DefaultIcon;\n// Hack end\n\ntype Position = L.LatLng|null\n\n// interface InvertPathOptions extends PathOptions {\n//     invert?: boolean\n// }\n\nfunction ForecastMarker() {\n    const [position, setPosition] = useState<Position>(null)\n    useMapEvents({\n        click(e) {\n            setPosition(e.latlng)\n        },\n    })\n\n    return position === null ? null : (\n        <Marker position={position}>\n            <Popup>\n                <Forecast position={ position }  />\n            </Popup>\n        </Marker>\n    )\n}\n\nexport default function ForecastMap() {\n    // Default coordinates set to Ethiopia.\n    const position : LatLngExpression = [9.016667, 38.75];\n    const zoom : number = 7;\n\n    const [boundary, setBoundary] = useState<GeoJsonObject>()\n\n    useEffect(() => {\n        const fetchEthiopiaBoundary = async () => {\n            fetch(\"/ethiopia_boundary.geojson\")\n            .then((response) => {\n                if (response.ok) {\n                    return response.json()\n                }\n            })\n            .then((new_boundary: GeoJsonObject) => {\n                setBoundary(new_boundary)\n            })\n        }\n        InvertPolygonExtension()\n        fetchEthiopiaBoundary()\n        console.log(\"load boundary\")\n    }, [])\n\n    \n    return (\n        <MapContainer center={position} zoom={zoom} scrollWheelZoom={false}>\n            <TileLayer\n               attribution=\"&copy; <a href='http://osm.org/copyright'>OpenStreetMap</a> contributors\"\n                url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n            />\n            { boundary && <GeoJSON data={boundary} pathOptions={ {fill: true, fillColor: \"#808080\", fillOpacity: 0.5} as PathOptions} /> }\n            \n            <ForecastMarker />\n            {\n                // Placeholder, we'll put our markers here\n            }\n        </MapContainer>\n        )\n};\n","\nimport L  from \"leaflet\";\n\nexport default function InvertPolygonExtension() {\n    // Use public isFlat if available, else fall back to private _flat\n    var isFlat = L.LineUtil.isFlat ? L.LineUtil.isFlat : L.LineUtil._flat;\n\n    function defineSnogylop(L) {\n\n        var worldLatlngs = [\n            L.latLng([90, 180]),\n            L.latLng([90, -180]),\n            L.latLng([-90, -180]),\n            L.latLng([-90, 180])\n        ];\n\n        var OriginalPolygon = {\n            toGeoJSON: L.Polygon.prototype.toGeoJSON\n        };\n        L.extend(L.Polygon.prototype, {\n            _setLatLngs: function(latlngs) {\n                this._originalLatLngs = latlngs;\n                if (isFlat(this._originalLatLngs)) {\n                    this._originalLatLngs = [this._originalLatLngs];\n                }\n                worldLatlngs = (this.options.worldLatLngs ?\n                    this.options.worldLatLngs :\n                    worldLatlngs);\n                // Create a new set of latlngs, adding our world-sized ring\n                // first\n                var newLatlngs = [];\n                newLatlngs.push(worldLatlngs);\n                for (var l in latlngs) {\n                    newLatlngs.push(latlngs[l]);\n                }\n                latlngs = [newLatlngs];\n                L.Polyline.prototype._setLatLngs.call(this, latlngs);\n            },\n            getBounds: function () {\n                if (this._originalLatLngs) {\n                    // Don't return the world-sized ring's bounds, that's not\n                    // helpful!\n                    return new L.LatLngBounds(this._originalLatLngs);\n                }\n                return new L.LatLngBounds(this.getLatLngs());\n            },\n            getLatLngs: function() {\n                return this._originalLatLngs;\n            },\n            toGeoJSON: function (precision) {\n                var holes = !isFlat(this._originalLatLngs),\n                    multi = holes && !isFlat(this._originalLatLngs[0]);\n                var coords = L.GeoJSON.latLngsToCoords(this._originalLatLngs, multi ? 2 : holes ? 1 : 0, true, precision);\n                if (!holes) {\n                    coords = [coords];\n                }\n                return L.GeoJSON.getFeature(this, {\n                    type: (multi ? 'Multi' : '') + 'Polygon',\n                    coordinates: coords\n                });\n            }\n        });\n    }\n\n     defineSnogylop(L);\n};\n","import React from 'react';\nimport './App.css';\nimport ForecastMap from './components/ForecastMap';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ForecastMap />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}